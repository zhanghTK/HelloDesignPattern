# 责任链模式

> 当你想要让一个以上的对象有机会能够处理某个请求的时候,就是用责任链模式(Chain of Responsibility Pattern).
>
> ——《Head First 设计模式》

所属类别:行为型模式。

典型使用场景：一个事件或请求需要多步判断/处理

针对这样的场景直接编码会造成哪些问题？
1. 多步的判断、处理集中在一起，违反单一职责；
2. 事件的处理依赖具体的过程，而不是行为或接口，违反依赖倒置；
3. 维护期需要新的处理过程时，必须修改原有代码，违反开闭原则；

首先，可以对具体在一起的业务代码代码进行了拆分，使业务逻辑的处理分散到多个模块；

其次，为了统一整个请求处理逻辑，抽象接口，整个请求的处理过程对外只需要暴露入口。

实现以上过程的UML类图如下：

![责任链模式.png](https://ooo.0o0.ooo/2017/01/04/586ceaf92cc2c.png)

责任链模式处理请求的一般过程：

![责任链模式处理流程 (1).png](https://ooo.0o0.ooo/2017/01/04/586cef1ec3144.png)

责任链模式的优点：

1. 对客户端来说并不能感知到责任链的存在（迪米特法则）；
2. 整个责任链的配置过程可以使用配置方式组装，后续处理节点的调整可以修改配置（开闭原则）；
3. 请求发送者与处理者的解耦
4. 简化了请求处理过程（单一职责）

典型的责任链模式使用场景：JavaEE Servlet Filter

---

代码场景说明：

模拟一个分级的请假审批机制，

`AbstractLeader`代表责任链中的抽象Handler

`Leader1`代表一级领导，负责审批小于等于三天的请假

`Leader2`代表二级领导，负责审批大于三天小于十天的请假

`Leader3`代表三级领导，责任审批大于等于十天小于三十天的假期，当请假超过30天驳回请假

`LeaveRequest`代表客户端发送的一个请假请求

`ChainTestConfig`使用Spring装配各个Bean

`ChainTest`运行整个责任链，模拟各种请假场景